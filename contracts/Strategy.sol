// SPDX-License-Identifier: AGPL-3.0
// Feel free to change the license, but this is what we use

// Feel free to change this version of Solidity. We support >=0.6.0 <0.7.0;
pragma solidity 0.6.12;
pragma experimental ABIEncoderV2;

// These are the core Yearn libraries
import {
    BaseStrategy,
    StrategyParams
} from "@yearnvaults/contracts/BaseStrategy.sol";
import {
    SafeERC20,
    SafeMath,
    IERC20,
    Address
} from "@openzeppelin/contracts/token/ERC20/SafeERC20.sol";

// Import interfaces for many popular DeFi projects, or add your own!
//import "../interfaces/<protocol>/<Interface>.sol";
import  "../interfaces/rari/IRariFundManager.sol";
import  "../interfaces/rari/IRariFundToken.sol";
import  "../interfaces/rari/IRariGovernanceTokenDistributor.sol";
import  "../interfaces/uniswap/IUniswapV2Router.sol";

contract Strategy is BaseStrategy {
    using SafeERC20 for IERC20;
    using Address for address;
    using SafeMath for uint256;

    uint256 private constant MAX_UINT256 = uint256(-1);
    uint256 private constant EXP = 1e18;

    IUniswapV2Router public uniswap;
    IRariFundManager public rari;
    string public rariCurrencyCode;
    IERC20 public rariFundToken;
    IERC20 public rariGovToken;
    IERC20 internal weth;

    constructor(address _vault) public BaseStrategy(_vault) {
        // You can set these parameters on deployment to whatever you want
        // maxReportDelay = 6300;
        // profitFactor = 100;
        // debtThreshold = 0;
    }

    function setRari(address _rari, string calldata _rariCurrencyCode, address _rariGovToken) external onlyAuthorized {
        if(address(rari) != address(0) && address(rari) != _rari){
            // Clear old approvals
            rariFundToken.approve(address(rari), 0);
            want.approve(address(rari), 0);
        }

        rari = IRariFundManager(_rari);
        rariCurrencyCode = _rariCurrencyCode;
        rariFundToken = IERC20(rari.rariFundToken());
        rariGovToken = IERC20(_rariGovToken);
        require(address(rariFundToken) != address(0), "Wrong RFT address on FundManager");

        rariFundToken.approve(address(rari), MAX_UINT256);
        want.approve(address(rari), MAX_UINT256);

        if(address(uniswap) != address(0)){
            rariGovToken.approve(address(uniswap), MAX_UINT256);
            weth.approve(address(uniswap), MAX_UINT256);
        }
    }

    function setUniswap(address _uniswapRouter) external onlyAuthorized  {
        if(address(uniswap) != address(0) && address(uniswap) != _uniswapRouter){
            // Clear old approvals
            if(address(rariGovToken) != address(0)){
                rariGovToken.approve(address(uniswap), 0);
            }
            weth.approve(address(uniswap), 0);
        }

        uniswap = IUniswapV2Router(_uniswapRouter);
        weth = IERC20(uniswap.WETH());
        require(address(weth) != address(0), "Wrong WETH address on router");

        rariGovToken.approve(address(uniswap), MAX_UINT256);
        weth.approve(address(uniswap), MAX_UINT256);
    }

    // ******** OVERRIDE THESE METHODS FROM BASE CONTRACT ************

    function name() external view override returns (string memory) {
        return "StrategyRariYieldERC20";
    }

    function estimatedTotalAssets() public view override returns (uint256) {
        // TODO: Build a more accurate estimate using the value of all positions in terms of `want`
        return want.balanceOf(address(this));
    }

    function prepareReturn(uint256 _debtOutstanding)
        internal
        override
        returns (
            uint256 _profit,
            uint256 _loss,
            uint256 _debtPayment
        )
    {
        // TODO: Do stuff here to free up any returns back into `want`
        // NOTE: Return `_profit` which is value generated by all positions, priced in `want`
        // NOTE: Should try to free up at least `_debtOutstanding` of underlying position

        if(_debtOutstanding > 0) {
            withdrawFunds(_debtOutstanding);
        } else {
            claimAndSwapRGT();
        }

        uint256 wantBalance = want.balanceOf(address(this));
        if(wantBalance >= _debtOutstanding) {
            _debtPayment = _debtOutstanding;
            _profit = wantBalance.sub(_debtPayment);
            //_loss = 0;
        }else{
            _debtPayment = wantBalance;
            //_profit = 0;
            _loss = _debtOutstanding.sub(_debtPayment);
        }
    }

    function adjustPosition(uint256 _debtOutstanding) internal override {
        // NOTE: Try to adjust positions so that `_debtOutstanding` can be freed up on *next* harvest (not immediately)

        uint256 wantBalance = want.balanceOf(address(this));
        if(wantBalance > _debtOutstanding) {
            // Deposit tokens we will not need soon
            uint256 depositAmount = wantBalance.sub(_debtOutstanding);
            rari.deposit(rariCurrencyCode, depositAmount);
        }
    }

    function liquidatePosition(uint256 _amountNeeded)
        internal
        override
        returns (uint256 _liquidatedAmount, uint256 _loss)
    {
        // NOTE: Maintain invariant `want.balanceOf(this) >= _liquidatedAmount`
        // NOTE: Maintain invariant `_liquidatedAmount + _loss <= _amountNeeded`

        if(_amountNeeded > 0) {
            withdrawFunds(_amountNeeded);
        } else {
            claimAndSwapRGT();
        }

        uint256 totalAssets = want.balanceOf(address(this));
        if (_amountNeeded > totalAssets) {
            _liquidatedAmount = totalAssets;
            _loss = _amountNeeded.sub(totalAssets);
        } else {
            _liquidatedAmount = _amountNeeded;
        }
    }

    // NOTE: Can override `tendTrigger` and `harvestTrigger` if necessary

    function withdrawFunds(uint256 wantAmount) internal {
        uint256 withdrawAmount = wantAmount.add(withdrawalFee(wantAmount));
        uint256 rftToBurn = usdToRft(withdrawAmount);
        uint256 rftBalance = rariFundToken.balanceOf(address(this));

        if(rftBalance < rftToBurn) {
            // We can only withdraw as much as we have. During withrawal we'll recieve some RGT
            withdrawAmount = rftToUsd(rftBalance);
        }

        rari.withdraw(rariCurrencyCode, withdrawAmount);
        swapRGT();
    }

    function claimAndSwapRGT() internal {
        IRariGovernanceTokenDistributor gov = IRariGovernanceTokenDistributor(IRariFundToken(address(rariFundToken)).rariGovernanceTokenDistributor());
        gov.distributeRgt(address(this), IRariGovernanceTokenDistributor.RariPool.Yield);

        swapRGT();
    }

    function swapRGT() internal {
        uint256 rgtBalance = rariGovToken.balanceOf(address(this));
        if(rgtBalance == 0) return;

        address[] memory path = new address[](2);

        // NOTE: Can not swap RGT to want directly because unoswap only has RGT to ETH pair
        // path[0] = address(rariGovToken);
        // path[1] = address(want);
        // uniswap.swapExactTokensForTokens(rgtBalance, 0, path, address(this), block.timestamp)

        path[0] = address(rariGovToken);
        path[1] = address(weth);
        uniswap.swapExactTokensForTokens(rgtBalance, 0, path, address(this), block.timestamp);

        uint256 wethBalance = weth.balanceOf(address(this));
        path[0] = address(weth);
        path[1] = address(want);
        uniswap.swapExactTokensForTokens(wethBalance, 0, path, address(this), block.timestamp);
    }


    function usdToRft(uint256 usdAmount) internal returns(uint256) {
        uint256 rftTotalSupply = rariFundToken.totalSupply();
        uint256 fundBalanceUsd = rari.getFundBalance();
        require(fundBalanceUsd > 0, "Rari fund balance is 0");
        return usdAmount.mul(rftTotalSupply).div(fundBalanceUsd);
    }
    function rftToUsd(uint256 rftAmount) internal returns(uint256) {
        uint256 rftTotalSupply = rariFundToken.totalSupply();
        uint256 fundBalanceUsd = rari.getFundBalance();
        require(rftTotalSupply > 0, "RFT total supply is 0");
        return rftAmount.mul(fundBalanceUsd).div(rftTotalSupply);
    }

    function withdrawalFee(uint256 usdAmount) internal returns(uint256) {
        uint256 withdrawalFeeRate = rari.getWithdrawalFeeRate();
        return usdAmount.mul(withdrawalFeeRate).div(EXP);
    }

    function prepareMigration(address _newStrategy) internal override {
        // NOTE: `migrate` will automatically forward all `want` in this strategy to the new one
        rariFundToken.safeTransfer(_newStrategy, rariFundToken.balanceOf(address(this)));
        rariGovToken.safeTransfer(_newStrategy, rariGovToken.balanceOf(address(this)));
    }

    // Override this to add all tokens/tokenized positions this contract manages
    // on a *persistent* basis (e.g. not just for swapping back to want ephemerally)
    // NOTE: Do *not* include `want`, already included in `sweep` below
    function protectedTokens()
        internal
        view
        override
        returns (address[] memory)
    {
        address[] memory protected = new address[](2);
        protected[0] = address(rariFundToken);
        protected[1] = address(rariGovToken);
        return protected;

    }
}
