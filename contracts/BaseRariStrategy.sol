// SPDX-License-Identifier: AGPL-3.0
// Feel free to change the license, but this is what we use

// Feel free to change this version of Solidity. We support >=0.6.0 <0.7.0;
pragma solidity 0.6.12;
pragma experimental ABIEncoderV2;

// These are the core Yearn libraries
import {
    BaseStrategy,
    StrategyParams
} from "@yearnvaults/contracts/BaseStrategy.sol";
import {
    SafeERC20,
    SafeMath,
    IERC20,
    Address
} from "@openzeppelin/contracts/token/ERC20/SafeERC20.sol";

// Import interfaces for many popular DeFi projects, or add your own!
//import "../interfaces/<protocol>/<Interface>.sol";
import  "../interfaces/IERC20Detailed.sol";
import  "../interfaces/rari/IRariFundManager.sol";
import  "../interfaces/rari/IRariFundToken.sol";
import  "../interfaces/rari/IRariGovernanceTokenDistributor.sol";
import  "../interfaces/uniswap/IUniswapV2Router.sol";

abstract contract BaseRariStrategy is BaseStrategy {
    using SafeERC20 for IERC20;
    using Address for address;
    using SafeMath for uint256;

    uint256 private constant MAX_UINT256 = uint256(-1);
    uint256 private constant EXP = 1e18;

    IUniswapV2Router public uniswap;
    IRariFundManager public rari;
    string public rariCurrencyCode;
    IERC20 public rariFundToken;
    IERC20 public rariGovToken;
    IERC20 internal weth;
    uint8 internal wantDecimals;
    uint256 internal storedDepositedBalance;

    constructor(address _vault) public BaseStrategy(_vault) {
        // You can set these parameters on deployment to whatever you want
        // maxReportDelay = 6300;
        // profitFactor = 100;
        // debtThreshold = 0;
    }

    function rariPoolType() internal virtual returns(IRariGovernanceTokenDistributor.RariPool);

    function setRari(address _rari, string calldata _rariCurrencyCode, address _rariGovToken) external onlyAuthorized {
        if(address(rari) != address(0) && address(rari) != _rari){
            // Clear old approvals
            rariFundToken.approve(address(rari), 0);
            want.approve(address(rari), 0);
        }

        rari = IRariFundManager(_rari);
        rariCurrencyCode = _rariCurrencyCode;
        rariFundToken = IERC20(rari.rariFundToken());
        rariGovToken = IERC20(_rariGovToken);
        require(address(rariFundToken) != address(0), "Wrong RFT address on FundManager");

        rariFundToken.approve(address(rari), MAX_UINT256);
        want.approve(address(rari), MAX_UINT256);

        if(address(uniswap) != address(0)){
            rariGovToken.approve(address(uniswap), MAX_UINT256);
            weth.approve(address(uniswap), MAX_UINT256);
        }
        
        wantDecimals = IERC20Detailed(address(want)).decimals();
    }

    function setUniswap(address _uniswapRouter) external onlyAuthorized  {
        if(address(uniswap) != address(0) && address(uniswap) != _uniswapRouter){
            // Clear old approvals
            if(address(rariGovToken) != address(0)){
                rariGovToken.approve(address(uniswap), 0);
            }
            weth.approve(address(uniswap), 0);
        }

        uniswap = IUniswapV2Router(_uniswapRouter);
        weth = IERC20(uniswap.WETH());
        require(address(weth) != address(0), "Wrong WETH address on router");

        rariGovToken.approve(address(uniswap), MAX_UINT256);
        weth.approve(address(uniswap), MAX_UINT256);
    }

    // ******** OVERRIDE THESE METHODS FROM BASE CONTRACT ************

    function name() external view override returns (string memory) {
        return "StrategyRariYieldERC20";
    }

    function estimatedTotalAssets() public view override returns (uint256) {
        // TODO: Calculate RGT rewards
        return want.balanceOf(address(this)).add(storedDepositedBalance);
    }

    function updateStoredDepositedBalance() public returns(uint256) {
        uint256 balanceUSD = rari.balanceOf(address(this));
        uint256 withdrawableUSD = balanceUSD.sub(withdrawalFee(balanceUSD));
        storedDepositedBalance = usdToWant(withdrawableUSD);
        return storedDepositedBalance;
    }

    function prepareReturn(uint256 _debtOutstanding)
        internal
        override
        returns (
            uint256 _profit,
            uint256 _loss,
            uint256 _debtPayment
        )
    {
        // NOTE: Return `_profit` which is value generated by all positions, priced in `want`
        // NOTE: Should try to free up at least `_debtOutstanding` of underlying position

        claimAndSwapRGT();
        uint256 wantBalance = want.balanceOf(address(this));

        if(_debtOutstanding > wantBalance) {
            withdrawFunds(_debtOutstanding.sub(wantBalance));
            wantBalance = want.balanceOf(address(this));
        }

        updateStoredDepositedBalance();
        
        if(wantBalance >= _debtOutstanding) {
            _debtPayment = _debtOutstanding;
            _profit = wantBalance.sub(_debtPayment);
            //_loss = 0;
        }else{
            _debtPayment = wantBalance;
            //_profit = 0;
            _loss = _debtOutstanding.sub(_debtPayment);
        }
    }

    function adjustPosition(uint256 _debtOutstanding) internal override {
        // NOTE: Try to adjust positions so that `_debtOutstanding` can be freed up on *next* harvest (not immediately)

        uint256 wantBalance = want.balanceOf(address(this));
        if(wantBalance > _debtOutstanding) {
            // Deposit tokens we will not need soon
            uint256 depositAmount = wantBalance.sub(_debtOutstanding);
            rariDeposit(depositAmount);
        }
        
        updateStoredDepositedBalance();
    }

    function liquidatePosition(uint256 _amountNeeded)
        internal
        override
        returns (uint256 _liquidatedAmount, uint256 _loss)
    {
        // NOTE: Maintain invariant `want.balanceOf(this) >= _liquidatedAmount`
        // NOTE: Maintain invariant `_liquidatedAmount + _loss <= _amountNeeded`
        
        claimAndSwapRGT();
        uint256 wantBalance = want.balanceOf(address(this));

        if(_amountNeeded > wantBalance) {
            withdrawFunds(_amountNeeded.sub(wantBalance));
            wantBalance = want.balanceOf(address(this));
        } 

        updateStoredDepositedBalance();

        if (_amountNeeded > wantBalance) {
            _liquidatedAmount = wantBalance;
            _loss = _amountNeeded.sub(wantBalance);
        } else {
            _liquidatedAmount = _amountNeeded;
        }
    }

    // NOTE: Can override `tendTrigger` and `harvestTrigger` if necessary

    function withdrawFunds(uint256 wantAmount) internal {
        uint256 wantAmountUsd = wantToUsd(wantAmount);
        uint256 withdrawAmountUsd = wantAmountUsd.add(withdrawalFee(wantAmountUsd));
        uint256 rftToBurn = usdToRft(withdrawAmountUsd);
        uint256 rftBalance = rariFundToken.balanceOf(address(this));

        if(rftBalance < rftToBurn) {
            // We can only withdraw as much as we have. During withrawal we'll recieve some RGT
            withdrawAmountUsd = rftToUsd(rftBalance);
        }

        rariWithdraw(usdToWant(withdrawAmountUsd));
        swapRGT();
    }

    function claimAndSwapRGT() internal {
        IRariGovernanceTokenDistributor gov = IRariGovernanceTokenDistributor(IRariFundToken(address(rariFundToken)).rariGovernanceTokenDistributor());
        gov.distributeRgt(address(this), rariPoolType());

        swapRGT();
    }

    function swapRGT() internal virtual {
        uint256 rgtBalance = rariGovToken.balanceOf(address(this));
        if(rgtBalance == 0) return;

        address[] memory path = new address[](3);

        // NOTE: Can not swap RGT to want directly because uniswap only has RGT to ETH pair
        path[0] = address(rariGovToken);
        path[1] = address(weth);
        path[2] = address(want);
        uniswap.swapExactTokensForTokens(rgtBalance, 0, path, address(this), block.timestamp);
    }

    function rariDeposit(uint256 amount) internal virtual {
        rari.deposit(rariCurrencyCode, amount);
    }

    function rariWithdraw(uint256 amount) internal virtual {
        rari.withdraw(rariCurrencyCode, amount);
    }

    function withdrawalFee(uint256 usdAmount) internal virtual returns(uint256) {
        uint256 withdrawalFeeRate = rari.getWithdrawalFeeRate();
        return usdAmount.mul(withdrawalFeeRate).div(EXP);
    }

    function usdToRft(uint256 usdAmount) internal returns(uint256) {
        uint256 rftTotalSupply = rariFundToken.totalSupply();
        uint256 fundBalanceUsd = rari.getFundBalance();
        require(fundBalanceUsd > 0, "Rari fund balance is 0");
        return usdAmount.mul(rftTotalSupply).div(fundBalanceUsd);
    }

    function rftToUsd(uint256 rftAmount) internal returns(uint256) {
        uint256 rftTotalSupply = rariFundToken.totalSupply();
        uint256 fundBalanceUsd = rari.getFundBalance();
        require(rftTotalSupply > 0, "RFT total supply is 0");
        return rftAmount.mul(fundBalanceUsd).div(rftTotalSupply);
    }

    function usdToWant(uint256 usdAmount)  internal returns(uint256) {
        return convertDecimals(usdAmount, 18, wantDecimals);
    }

    function wantToUsd(uint256 wantAmount)  internal returns(uint256) {
        return convertDecimals(wantAmount, wantDecimals, 18);
    }

    function convertDecimals(uint256 amount, uint8 source, uint8 target) internal returns(uint256) {
        if (source == target) {
            return amount;
        } else if (source > target) {
            return amount.div(10**uint256(source-target));
        } else {
            return amount.mul(10**uint256(target-source));
        }
    }

    function prepareMigration(address _newStrategy) internal override {
        // NOTE: `migrate` will automatically forward all `want` in this strategy to the new one
        rariFundToken.safeTransfer(_newStrategy, rariFundToken.balanceOf(address(this)));
        rariGovToken.safeTransfer(_newStrategy, rariGovToken.balanceOf(address(this)));
    }

    // Override this to add all tokens/tokenized positions this contract manages
    // on a *persistent* basis (e.g. not just for swapping back to want ephemerally)
    // NOTE: Do *not* include `want`, already included in `sweep` below
    function protectedTokens()
        internal
        view
        override
        returns (address[] memory)
    {
        address[] memory protected = new address[](2);
        protected[0] = address(rariFundToken);
        protected[1] = address(rariGovToken);
        return protected;

    }
}
